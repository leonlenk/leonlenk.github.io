---
const {
  numStars = 75, // Original number of stars
  starColor = "white",
  minSize = 3, // Reduced from 5 for better performance
  maxSize = 15, // Reduced from 20 for better performance
  minDuration = 4, // Increased from 3 for better performance
  maxDuration = 6, // Increased from 4.5 for better performance
} = Astro.props;
---

<div
  id="star-background"
  class="starBackground"
  style={`--star-color: ${starColor};`}
  data-num-stars={numStars}
  data-min-size={minSize}
  data-max-size={maxSize}
  data-min-duration={minDuration}
  data-max-duration={maxDuration}
>
</div>

<script>
  // Performance-optimized stars implementation
  (function() {
    'use strict';
    
    let stars = [];
    let isActive = false;
    let animationId = null;
    let lastScrollY = 0;
    let scrollThrottle = null;
    let resizeThrottle = null;
    
    // Use Intersection Observer to only animate when visible
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '50px'
    };
    
    function initStars() {
      const starBackground = document.getElementById("star-background");
      if (!starBackground) return;
      
      // Check if already initialized
      if (starBackground.dataset.initialized === 'true') return;
      
             const numStars = parseInt(starBackground.dataset.numStars) || 75;
      const minSize = parseInt(starBackground.dataset.minSize) || 3;
      const maxSize = parseInt(starBackground.dataset.maxSize) || 15;
      const minDuration = parseFloat(starBackground.dataset.minDuration) || 4;
      const maxDuration = parseFloat(starBackground.dataset.maxDuration) || 6;
      
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      
      // Pre-create star elements for better performance
      const fragment = document.createDocumentFragment();
      
      for (let i = 0; i < numStars; i++) {
        const starElement = document.createElement("span");
        starElement.classList.add("star");
        starElement.textContent = "âœ¶";
        
        const size = Math.random() * (maxSize - minSize) + minSize;
        const duration = Math.random() * (maxDuration - minDuration) + minDuration;
        const delay = Math.random() * duration;
        
        // Use CSS custom properties for better performance
        starElement.style.setProperty('--star-size', `${size}px`);
        starElement.style.setProperty('--star-x', `${Math.random() * screenWidth}px`);
        starElement.style.setProperty('--star-y', `${Math.random() * screenHeight}px`);
        starElement.style.setProperty('--star-duration', `${duration}s`);
        starElement.style.setProperty('--star-delay', `${delay}s`);
        starElement.style.setProperty('--star-z', `${Math.random() * 0.6 + 0.3}`);
        
        fragment.appendChild(starElement);
        
        stars.push({
          element: starElement,
          x: parseFloat(starElement.style.getPropertyValue('--star-x')),
          y: parseFloat(starElement.style.getPropertyValue('--star-y')),
          z: parseFloat(starElement.style.getPropertyValue('--star-z')),
          size: size
        });
      }
      
      starBackground.appendChild(fragment);
      starBackground.dataset.initialized = 'true';
      
      // Start animation only when visible
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !isActive) {
            startAnimation();
          } else if (!entry.isIntersecting && isActive) {
            stopAnimation();
          }
        });
      }, observerOptions);
      
      observer.observe(starBackground);
    }
    
    function startAnimation() {
      if (isActive) return;
      isActive = true;
      updatePositions();
    }
    
    function stopAnimation() {
      if (!isActive) return;
      isActive = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }
    
    function updatePositions() {
      if (!isActive) return;
      
      const deltaScroll = window.scrollY - lastScrollY;
      lastScrollY = window.scrollY;
      
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      
      // Batch DOM updates for better performance
      const updates = [];
      
      stars.forEach((star) => {
        star.y -= deltaScroll * star.z;
        
        // Recycle stars that go out of view
        if (star.y < -star.size) {
          star.x = Math.random() * screenWidth;
          star.y += screenHeight + star.size * 2;
        } else if (star.y > screenHeight + star.size) {
          star.x = Math.random() * screenWidth;
          star.y -= screenHeight + star.size * 2;
        }
        
        updates.push({
          element: star.element,
          x: star.x,
          y: star.y
        });
      });
      
      // Apply all updates in one batch
      updates.forEach(update => {
        update.element.style.setProperty('--translate-x', `${update.x}px`);
        update.element.style.setProperty('--translate-y', `${update.y}px`);
      });
      
      animationId = requestAnimationFrame(updatePositions);
    }
    
    // Throttled scroll handler
    function handleScroll() {
      if (scrollThrottle) return;
      
      scrollThrottle = requestAnimationFrame(() => {
        // Scroll handling is now done in updatePositions
        scrollThrottle = null;
      });
    }
    
    // Throttled resize handler
    function handleResize() {
      if (resizeThrottle) return;
      
      resizeThrottle = setTimeout(() => {
        const starBackground = document.getElementById("star-background");
        if (starBackground) {
          // Reset initialization to recreate stars
          starBackground.dataset.initialized = 'false';
          starBackground.innerHTML = '';
          stars = [];
          initStars();
        }
        resizeThrottle = null;
      }, 250);
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initStars);
    } else {
      initStars();
    }
    
    // Event listeners with throttling
    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('resize', handleResize, { passive: true });
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      stopAnimation();
      if (scrollThrottle) cancelAnimationFrame(scrollThrottle);
      if (resizeThrottle) clearTimeout(resizeThrottle);
    });
    
    // Handle Astro page transitions
    document.addEventListener('astro:after-swap', () => {
      stopAnimation();
      stars = [];
      initStars();
    });
    
  })();
</script>

<style lang="scss" is:global>
  .starBackground {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
    pointer-events: none;
    will-change: transform;
  }

  .star {
    position: absolute;
    top: 0;
    left: 0;
    color: var(--star-color, white);
    display: inline-block;
    font-size: var(--star-size);
    line-height: var(--star-size);
    text-shadow: 0 0 15px rgba(255, 255, 255, 1);
    transform: translate3d(var(--translate-x, var(--star-x)), var(--translate-y, var(--star-y)), 0)
      scale(var(--animation-scale, 1));
    will-change: transform;
    animation: twinkle var(--star-duration) ease-in-out infinite;
    animation-delay: var(--star-delay);
  }

  @keyframes twinkle {
    0% {
      opacity: 1;
      --animation-scale: 1;
      text-shadow:
        0 0 20px rgba(255, 255, 255, 1),
        0 0 30px rgba(255, 255, 255, 0.8);
    }
    30%,
    85% {
      opacity: 0.8;
      --animation-scale: 0.7;
      text-shadow: 0 0 15px rgba(255, 255, 255, 1);
    }
    100% {
      opacity: 1;
      --animation-scale: 1;
      text-shadow:
        0 0 20px rgba(255, 255, 255, 1),
        0 0 30px rgba(255, 255, 255, 0.8);
    }
  }
</style>
